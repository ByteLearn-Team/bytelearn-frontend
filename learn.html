<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>BytLearn — Learn</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&family=Playfair+Display:wght@700;800&display=swap" rel="stylesheet" />
  
  <style>
    /* Define CSS custom properties for consistent theming across the application */
    :root {
      --border: rgba(255,255,255,0.2);
      --glass: rgba(255,255,255,0.1);
      --text: #fff;
      --muted: rgba(255,255,255,0.85);
      --accent: #e5a054;
      --accent-glow: rgba(229, 160, 84, 0.3);
    }

    /* Reset box-sizing for all elements to include padding and border in element's total width/height */
    * { 
      box-sizing: border-box; 
    }

    /* Set full viewport height and base font styling for html and body */
    html, body {
      height: 100%;
      margin: 0;
      font-family: 'Inter', ui-sans-serif, system-ui, -apple-system, 'Segoe UI', Roboto, Helvetica, Arial;
      color: var(--text);
      text-align: center;
    }

    /* Create gradient background and set up base body styles */
    body {
      background: linear-gradient(135deg, #7e22ce 0%, #f472b6 45%, #6366f1 100%);
      background-attachment: fixed;
      position: relative;
      overflow-x: hidden;
      font-size: 18px;
      text-align: center;
    }

    /* Add dark overlay to body for better text readability over gradient */
    body::before {
      content: "";
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.35);
      pointer-events: none;
      z-index: 0;
    }

    /* Additional overlay layer for visual depth */
    .overlay { 
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.35);
    }

    /* Container for content sections with max-width and centered alignment */
    .container {
      position: relative;
      z-index: 1;
      max-width: 1200px;
      margin: 0 auto;
      padding: 32px;
      text-align: center;
    }

    /* Ensure main content area has minimum height accounting for header space */
    main.container { 
      min-height: calc(100vh - 110px); 
    }

    /* Flexbox row layout for header and navigation elements */
    .row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      text-align: center;
    }

    /* Logo container with icon and text layout */
    .logo { 
      display: flex;
      align-items: center;
      gap: 12px;
    }

    /* Set logo image dimensions */
    .logo img { 
      width: 70px;
      height: 70px;
    }

    /* Button styling with glassmorphism effect and smooth transitions */
    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 12px 16px;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.18);
      color: var(--text);
      text-decoration: none;
      transition: 150ms;
      backdrop-filter: blur(6px);
    }

    /* Increase button background opacity on hover for visual feedback */
    .btn:hover { 
      background: rgba(255,255,255,0.24);
    }

    /* Card component with glassmorphism effect for content containers */
    .card {
      background: var(--glass);
      border: 1px solid var(--border);
      border-radius: 18px;
      padding: 14px;
      backdrop-filter: blur(8px);
      text-align: center;
    }

    /* Ensure summary card takes full width of its container */
    #summary.card {
      max-width: 100%;
      width: 100%;
      margin-left: auto;
      margin-right: auto;
      box-sizing: border-box;
    }

    /* Single column grid layout for summary content */
    #summary .grid {
      max-width: 100%;
      width: 100%;
      margin-left: auto;
      margin-right: auto;
      grid-template-columns: 1fr;
    }

    /* Nested cards within summary section inherit full width */
    #summary .card {
      width: 100%;
      max-width: 100%;
      margin-left: auto;
      margin-right: auto;
      box-sizing: border-box;
    }

    /* Four-column grid layout for navigation pills */
    .pills {
      display: grid;
      grid-template-columns: repeat(4, minmax(0,1fr)); 
      gap: 12px;
    }

    /* Individual pill button styling with subtle glassmorphism */
    .pill {
      padding: 10px 16px;
      border-radius: 14px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.08);
      color: var(--text);
      box-shadow: inset 0 0 0 1px rgba(255,255,255,0.06);
    }

    /* Active state for selected pill with increased opacity */
    .pill.active {
      background: rgba(255,255,255,0.2);
      box-shadow: inset 0 0 0 1px rgba(255,255,255,0.12);
    }

    /* Utility class to hide elements */
    .hidden { 
      display: none !important; 
    }

    /* Heading styling with tight letter spacing */
    h2 { 
      margin: 0 0 12px;
      font-weight: 800;
      font-size: 28px;
      letter-spacing: -0.5px;
    }

    /* Paragraph text with slightly muted color */
    p { 
      color: var(--muted);
    }

    /* Single column grid by default for responsive layouts */
    .grid { 
      display: grid;
      grid-template-columns: 1fr;
      gap: 12px;
    }

    /* Two-column grid layout for larger screens */
    @media(min-width:768px) { 
      .grid { 
        grid-template-columns: 1fr 1fr;
      } 
    }

    /* Flashcard container uses flexbox for centered vertical layout */
    #flashcards .grid { 
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      min-height: 300px;
      position: relative;
      overflow: visible;
    }
    
    /* Container for flashcard carousel with fixed dimensions */
    .flashcard-container {
      position: relative;
      width: 100%;
      max-width: 1000px;
      height: 350px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    /* Navigation arrow buttons positioned on sides of carousel */
    .nav-arrow {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: rgba(255,255,255,0.18);
      border: 1px solid var(--border);
      backdrop-filter: blur(6px);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: 150ms;
      z-index: 20;
      font-size: 20px;
      color: var(--text);
      user-select: none;
    }

    /* Hover effect for navigation arrows */
    .nav-arrow:hover {
      background: rgba(255,255,255,0.24);
    }

    /* Position left arrow on the left side */
    .nav-arrow.left {
      left: 10px;
    }

    /* Position right arrow on the right side */
    .nav-arrow.right {
      right: 10px;
    }

    /* Disabled state maintains visibility for navigation arrows */
    .nav-arrow.disabled {
      opacity: 1;
      cursor: pointer;
    }
    
    /* Wrapper for custom scrollbar below flashcards */
    .flashcard-scrollbar-wrapper {
      width: 100%;
      max-width: 1000px;
      margin-top: 20px;
      padding: 0 10px;
    }
    
    /* Custom scrollbar track for flashcard navigation */
    .flashcard-scrollbar {
      width: 100%;
      height: 8px;
      background: rgba(255,255,255,0.1);
      border-radius: 4px;
      position: relative;
      cursor: pointer;
      backdrop-filter: blur(6px);
      border: 1px solid var(--border);
    }
    
    /* Scrollbar thumb represents current position in flashcard stack */
    .flashcard-scrollbar-thumb {
      height: 100%;
      background: rgba(255,255,255,0.4);
      border-radius: 4px;
      position: absolute;
      left: 0;
      transition: background 0.2s;
      cursor: grab;
    }
    
    /* Hover state for scrollbar thumb */
    .flashcard-scrollbar-thumb:hover {
      background: rgba(255,255,255,0.5);
    }
    
    /* Active dragging state for scrollbar thumb */
    .flashcard-scrollbar-thumb:active {
      cursor: grabbing;
      background: rgba(255,255,255,0.6);
    }
    
    /* Force center alignment for all text elements throughout the application */
    h2, h3, h1, p, .badge, .subtitle, .title, .lead, .actions, .stats, .pill, .item a, .list, .li {
      text-align: center !important;
    }

    /* Add focus indicator for flashcards when interacted with */
    .flashcard {
      transition: box-shadow 0.2s;
    }

    .flashcard:active, .flashcard:focus {
      box-shadow: 0 0 0 4px #a21caf;
    }

    /* Summary text container with styled background and left-aligned text */
    .summary-text {
      white-space: pre-wrap;
      text-align: left;
      font-size: 16px;
      margin: 24px 40px;
      padding: 20px 32px;
      line-height: 1.8;
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      letter-spacing: 0.01em;
      background: rgba(255,255,255,0.05);
      border-radius: 12px;
      border-left: 4px solid var(--accent);
      box-shadow: inset 0 0 0 1px rgba(255,255,255,0.1);
    }

    /* Heading style within summary text with accent color and decorative border */
    .summary-text .heading {
      display: block !important;
      font-weight: 800 !important;
      color: var(--accent) !important;
      font-size: 22px !important;
      margin: 32px 0 16px 0 !important;
      padding-bottom: 12px !important;
      border-bottom: 3px solid var(--accent) !important;
      text-align: left !important;
      font-family: 'Playfair Display', 'Inter', serif !important;
      letter-spacing: -0.02em !important;
      width: 100%;
      text-shadow: 0 2px 8px var(--accent-glow);
      position: relative;
    }

    /* Decorative gradient underline for headings */
    .summary-text .heading::before {
      content: '';
      position: absolute;
      bottom: -3px;
      left: 0;
      width: 60px;
      height: 3px;
      background: linear-gradient(90deg, #fff 0%, var(--accent) 100%);
      box-shadow: 0 0 10px var(--accent-glow);
    }

    /* Remove top margin from first heading in summary */
    .summary-text .heading:first-child {
      margin-top: 0 !important;
    }

    /* Paragraph styling within summary text */
    .summary-text p {
      margin: 12px 0;
      text-align: left;
      color: rgba(255,255,255,0.95);
      font-weight: 500;
    }

    /* Bold text styling within summaries */
    .summary-text strong {
      color: #fff;
      font-weight: 700;
    }
    
    /* Flashcard content text with serif font and justified alignment */
    .flashcard-text {
      white-space: pre-wrap;
      font-family: "Times New Roman", Times, serif;
      text-align: justify;
      font-size: 19px;
      margin: 16px 30px;
      padding: 0 0 0 2px;
    }

    /* Individual flashcard styling with absolute positioning for carousel effect */
    .card-item {
      position: absolute;
      width: 480px;
      height: 350px;
      border-radius: 18px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 20px;
      background: var(--glass);
      border: 1px solid var(--border);
      backdrop-filter: blur(8px);
      transition: transform 0.4s ease, opacity 0.4s ease, left 0.4s ease;
      cursor: pointer;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      user-select: none;
    }
    
    /* Visited cards appear stacked on the left with reduced scale and opacity */
    .card-item.visited {
      left: -120px;
      transform: scale(0.75);
      opacity: 0.5;
      z-index: 5;
    }
    
    /* First visited card positioning */
    .card-item.visited:nth-child(1) {
      left: -120px;
      z-index: 5;
    }
    
    /* Second visited card slightly more visible */
    .card-item.visited:nth-child(2) {
      left: -100px;
      z-index: 6;
    }
    
    /* Third visited card most visible in stack */
    .card-item.visited:nth-child(3) {
      left: -80px;
      z-index: 7;
    }
    
    /* Current card centered and at full scale/opacity */
    .card-item.current {
      left: 50%;
      transform: translateX(-50%) scale(1);
      opacity: 1;
      z-index: 10;
    }
    
    /* Unvisited cards stacked on the right with reduced scale and opacity */
    .card-item.unvisited {
      left: auto;
      right: -120px;
      transform: scale(0.75);
      opacity: 0.5;
      z-index: 5;
    }
    
    /* Last unvisited card positioning */
    .card-item.unvisited:nth-last-child(1) {
      right: -120px;
      z-index: 5;
    }
    
    /* Second-to-last unvisited card */
    .card-item.unvisited:nth-last-child(2) {
      right: -100px;
      z-index: 6;
    }
    
    /* Third-to-last unvisited card */
    .card-item.unvisited:nth-last-child(3) {
      right: -80px;
      z-index: 7;
    }

    /* Front side of flashcard with purple gradient background */
    .card-front {
      background: linear-gradient(135deg, rgba(162, 28, 175, 0.4) 0%, rgba(109, 40, 217, 0.4) 100%);
    }

    /* Back side of flashcard with gold gradient background */
    .card-back {
      background: linear-gradient(135deg, rgba(251, 191, 36, 0.25) 0%, rgba(245, 158, 11, 0.25) 100%);
    }

    /* Title text on flashcard */
    .flashcard-title {
      font-size: 20px;
      font-weight: 800;
      color: #ffffff;
      margin-bottom: 16px;
      text-align: center;
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      letter-spacing: 0.3px;
    }

    /* Main content area on flashcard back with scrollable overflow */
    .flashcard-content {
      font-size: 17px;
      line-height: 1.8;
      text-align: justify;
      text-align-last: center;
      color: #ffffff;
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      overflow-y: auto;
      max-height: 100%;
      font-weight: 600;
      text-shadow: 0 1px 3px rgba(0, 0, 0, 0.15);
      letter-spacing: 0.3px;
      word-spacing: 0.5px;
      padding: 0 8px;
      hyphens: auto;
    }

    /* Prompt text shown on flashcard front */
    .flashcard-prompt {
      font-size: 22px;
      font-weight: 800;
      color: #ffffff;
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      text-shadow: 0 2px 6px rgba(0, 0, 0, 0.25);
      letter-spacing: 0.5px;
    }

    /* Hide weight indicator on flashcards */
    .flashcard > div[style*="font-weight:600"] {
      display: none;
    }

    /* Tab section header styling with gradient background */
    .tab > .row {
      background: linear-gradient(135deg, rgba(255,255,255,0.1) 0%, rgba(255,255,255,0.05) 100%);
      padding: 16px 20px;
      border-radius: 12px;
      margin-bottom: 16px;
      border: 1px solid rgba(255,255,255,0.15);
    }

    /* Loading indicator with pulsing animation */
    .loading-text {
      color: var(--muted);
      margin: 24px 0;
      font-weight: 500;
      animation: pulse 2s ease-in-out infinite;
    }

    /* Keyframe animation for loading pulse effect */
    @keyframes pulse {
      0%, 100% { 
        opacity: 0.6;
      }
      50% { 
        opacity: 1;
      }
    }

    /* Error message styling with warning icon */
    .error-message {
      color: #fca5a5;
      font-weight: 500;
      margin: 24px 0;
      font-size: 16px;
      letter-spacing: 0.01em;
      opacity: 0.95;
    }

    /* Add warning icon before error messages */
    .error-message::before {
      content: "⚠ ";
      margin-right: 6px;
      opacity: 0.9;
    }

    /* Custom scrollbar styling for summary text */
    .summary-text::-webkit-scrollbar {
      width: 8px;
    }

    .summary-text::-webkit-scrollbar-track {
      background: rgba(255,255,255,0.05);
      border-radius: 4px;
    }

    .summary-text::-webkit-scrollbar-thumb {
      background: rgba(255,255,255,0.2);
      border-radius: 4px;
    }

    .summary-text::-webkit-scrollbar-thumb:hover {
      background: rgba(255,255,255,0.3);
    }
  </style>
</head>

<body>
  <div class="overlay"></div>
  
  <!-- Header section with logo and navigation -->
  <header class="container">
    <div class="row">
      <!-- Logo and brand name with click handler to return to welcome page -->
      <div class="logo" style="cursor:pointer;" onclick="location.href='./welcome.html'">
        <img src="./logo.png" alt="BytLearn" />
        <div>
          <div style="font-weight:800;font-size:22px;">BytLearn</div>
          <!-- Display current user's name from localStorage -->
          <div style="font-size:12px;opacity:.8">Learning Workspace — <span id="lName">Student</span></div>
        </div>
      </div>
      
      <!-- Navigation buttons for main application sections -->
      <div class="row" style="gap:10px;">
        <a class="btn" href="./dashboard.html">Dashboard</a>
        <a class="btn" href="./profile.html" title="Profile">Profile</a>
        <!-- Sign out button that clears authentication and redirects -->
        <a class="btn" href="./welcome.html"
           onclick="event.preventDefault(); localStorage.removeItem('authed'); location.href='./welcome.html';">
          Sign Out
        </a>
      </div>
    </div>
  </header>
  
  <main class="container">
    <!-- Tab navigation pills for switching between different learning modes -->
    <div class="card" style="margin-bottom:12px;">
      <div class="pills">
        <button class="pill active" data-tab="summary">Summaries</button>
        <button class="pill" data-tab="flashcards">Flashcards</button>
        <button class="pill" data-tab="doubts">Doubt Asking</button>
        <button class="pill" data-tab="quizzes">Quizzes</button>
      </div>
    </div>
    
    <!-- Summary section - displays chapter summaries -->
    <section id="summary" class="card tab">
      <div class="row" style="justify-content:space-between;">
        <h2>Chapter Summary</h2>
        <span class="pill" style="cursor:default;">Summary</span>
      </div>
      <p></p>
      <!-- Grid container for summary content, populated dynamically -->
      <div class="grid" style="margin-top:10px">
      </div>
    </section>
    
    <!-- Flashcards section - interactive card-based learning -->
    <section id="flashcards" class="card tab hidden">
      <div class="row" style="justify-content:space-between;">
        <h2>Flashcards</h2>
        <span class="pill" style="cursor:default;">Recall</span>
      </div>
      <!-- Grid container for flashcard carousel, populated dynamically -->
      <div class="grid" style="margin-top:10px"></div>
    </section>
    
    <!-- Doubts section - AI-powered Q&A interface -->
    <section id="doubts" class="tab hidden"
  style="background:var(--glass);border:1px solid var(--border);border-radius:22px;padding:24px;box-shadow:0 8px 32px rgba(0,0,0,0.18);backdrop-filter:blur(12px);text-align:left;width:100%;max-width:100%;margin:0;display:flex;flex-direction:column;height:calc(100vh - 280px);">
      <div class="row" style="justify-content:space-between;align-items:center;margin-bottom:18px;flex-shrink:0;">
        <h2 style="font-size:32px;font-weight:800;margin:0;text-align:left;">Ask a Doubt</h2>
        <span class="pill" style="cursor:default;font-size:20px;padding:10px 18px;">?</span>
      </div>
      <!-- Chat history container - scrollable area showing conversation -->
      <div id="rag-chat-history" style="flex:1;overflow-y:auto;background:rgba(255,255,255,0.08);border-radius:18px;padding:18px;margin-bottom:18px;text-align:left;font-size:18px;box-shadow:inset 0 0 0 1px rgba(0,0,0,0.06);display:flex;flex-direction:column;gap:8px;min-height:0;">
        <div style="color:var(--muted);text-align:left;">Clear your Doubts...</div>
      </div>
      <!-- Input form for submitting questions -->
      <form id="rag-chat-form" style="display:flex;gap:12px;align-items:center;flex-shrink:0;" autocomplete="off" onsubmit="return false;">
        <input id="rag-chat-input" type="text" placeholder="Type your doubt..." style="flex:1;padding:14px 18px;border-radius:14px;border:1px solid var(--border);background:rgba(255,255,255,0.13);color:var(--text);font-size:18px;outline:none;text-align:left;" />
        <button type="submit" class="btn" style="padding:14px 28px;font-size:18px;">Send</button>
      </form>
    </section>
    
    <!-- Quizzes section - multiple choice question interface -->
    <section id="quizzes" class="card tab hidden">
      <div class="row" style="justify-content:space-between;">
        <h2>Quick Quiz</h2>
        <span class="pill" style="cursor:default;">Practice</span>
      </div>
      <p>Test yourself with quick objective questions and instant feedback.</p>
        <!-- Button container for quiz generation -->
        <div id="quiz-controls" style="margin:18px 0;">
          <button id="generate-quiz-btn" class="btn" style="font-size:16px;padding:10px 22px;">Generate Quiz</button>
        </div>
        <!-- Container where quiz questions will be rendered -->
        <div id="quiz-area"></div>
    </section>
  </main>

  <script>
    /* 
       QUIZ FUNCTIONALITY
 */
    
    const quizArea = document.getElementById('quiz-area');
    const quizControls = document.getElementById('quiz-controls');
    const generateQuizBtn = document.getElementById('generate-quiz-btn');
    let quizData = null; // Stores the current quiz questions and answers

    if (generateQuizBtn) {
      // When user clicks generate quiz button, fetch questions from backend
      generateQuizBtn.addEventListener('click', async function() {
        quizArea.innerHTML = '<div class="loading-text">Generating quiz...</div>';
        generateQuizBtn.disabled = true; // Prevent multiple simultaneous requests
        
        try {
          // Request quiz generation from backend API
          const res = await fetch('/generate_quiz', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ topic: 'current' })
          });
          const data = await res.json();
          
          // Validate response contains questions array
          if (data && Array.isArray(data.questions) && data.questions.length > 0) {
            quizData = data.questions;
            renderQuiz(quizData);
          } else {
            quizArea.innerHTML = '<div class="error-message">No quiz questions generated.</div>';
            generateQuizBtn.disabled = false;
          }
        } catch (e) {
          // Handle network or parsing errors
          quizArea.innerHTML = '<div class="error-message">Error generating quiz: ' + (e.message || e) + '</div>';
          generateQuizBtn.disabled = false;
        }
      });
    }

    /**
     * Renders quiz questions with multiple choice options
     * Creates form with radio buttons for each question
     */
    function renderQuiz(questions) {
      if (!questions || !questions.length) {
        quizArea.innerHTML = '<div class="error-message">No quiz questions available.</div>';
        return;
      }
      
      let html = '<form id="quiz-form-area">';
      
      // Build HTML for each question with its options
      questions.forEach((q, idx) => {
        html += `<div class="card" style="margin-bottom:18px;text-align:left;">
          <div style="font-weight:600;margin-bottom:8px;">Q${idx+1}. ${q.question || ''}</div>
          <ul style="opacity:.85;line-height:1.8;list-style-type:upper-alpha;">
            ${q.options.map((opt, oidx) => `
              <li style="margin-bottom:6px;">
                <label style="cursor:pointer;">
                  <input type="radio" name="q${idx}" value="${oidx}" style="margin-right:8px;" />
                  ${opt}
                </label>
              </li>
            `).join('')}
          </ul>
        </div>`;
      });
      
      html += '<button type="submit" class="btn" style="font-size:16px;padding:10px 22px;">Submit Quiz</button>';
      html += '</form>';
      
      quizArea.innerHTML = html;

      const quizForm = document.getElementById('quiz-form-area');
      if (quizForm) {
        // Handle quiz submission and scoring
        quizForm.addEventListener('submit', function(e) {
          e.preventDefault();
          if (!quizData || !quizData.length) return;
          
          let correct = 0;
          let total = quizData.length;
          
          // Compare each selected answer with correct answer
          quizData.forEach((q, idx) => {
            const selected = quizForm.querySelector(`input[name='q${idx}']:checked`);
            if (selected && q.answer !== undefined && Number(selected.value) === q.answer) correct++;
          });
          
          // Display score to user
          quizArea.innerHTML += `<div style='margin:18px 0;font-size:18px;font-weight:600;'>You got ${correct} out of ${total} correct.</div>`;
        });
      }
      generateQuizBtn.disabled = false; // Re-enable generate button after rendering
    }

    /* 
       Doubt Sestion
 */
    
    const chatForm = document.getElementById('chat-form');
    const chatInput = document.getElementById('chat-input');
    const chatHistory = document.getElementById('chat-history');

    if (chatForm && chatInput && chatHistory) {
      // Handle chat message submission
      chatForm.addEventListener('submit', async function() {
        const userMsg = chatInput.value.trim();
        if (!userMsg) return; // Ignore empty messages
        
        addMsg('You', userMsg, 'right');
        chatInput.value = '';
        chatInput.disabled = true; // Disable input while processing
        
        // Show loading indicator while waiting for response
        const loadingId = addMsg('Bot', '<span style="opacity:.7;">Thinking...</span>', 'left', true);
        
        try {
          // Send message to backend API
          const res = await fetch('http://127.0.0.1:8000/generate', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ prompt: userMsg })
          });
          const data = await res.json();
          
          removeMsg(loadingId); // Remove loading indicator
          
          // Display bot response or error message
          if (data.answer) {
            addMsg('Bot', data.answer, 'left');
          } else if (data.error) {
            addMsg('Bot', `<span style='color:#fca5a5;font-weight:500;'>⚠ ${data.error}</span>`, 'left');
          } else {
            addMsg('Bot', '<span style="color:#fca5a5;font-weight:500;">⚠ No answer received.</span>', 'left');
          }
        } catch (e) {
          // Handle network errors
          removeMsg(loadingId);
          addMsg('Bot', `<span style='color:#fca5a5;font-weight:500;'>⚠ Error: ${e.message}</span>`, 'left');
        }
        
        chatInput.disabled = false; // Re-enable input
        chatInput.focus();
      });
      
      /**
       * Adds a message to the chat history
       * @param {string} sender - Name of message sender
       * @param {string} text - Message content (can include HTML)
       * @param {string} align - 'left' or 'right' alignment
       * @param {boolean} isLoading - Whether this is a loading indicator
       * @returns {string|null} - ID of message if loading, null otherwise
       */
      function addMsg(sender, text, align, isLoading) {
        const msg = document.createElement('div');
        msg.className = 'chat-msg';
        msg.style = `margin:8px 0;display:flex;justify-content:${align==='right'?'flex-end':'flex-start'};`;
        msg.innerHTML = `<div style="max-width:80%;background:${align==='right'?'#a21caf':'rgba(255,255,255,0.13)'};color:${align==='right'?'#fff':'var(--text)'};padding:10px 14px;border-radius:12px;font-size:16px;box-shadow:0 1px 4px 0 rgba(0,0,0,0.07);">${text}</div>`;
        chatHistory.appendChild(msg);
        chatHistory.scrollTop = chatHistory.scrollHeight; // Auto-scroll to bottom
        
        // Generate unique ID for loading messages so they can be removed
        if (isLoading) {
          const id = 'loading-' + Math.random().toString(36).slice(2);
          msg.id = id;
          return id;
        }
        return null;
      }
      
      /**
       * Removes a message from chat history by ID
       * Used to remove loading indicators
       */
      function removeMsg(id) {
        const el = document.getElementById(id);
        if (el) el.remove();
      }
    }

    /* ===========================
       AUTHENTICATION CHECK
       Redirects unauthenticated users to login page
       =========================== */
    
    if (localStorage.getItem('authed') !== '1') {
      location.replace('./login.html');
    }

    /* ===========================
       TAB SWITCHING FUNCTIONALITY
       Handles navigation between different learning sections
       =========================== */
    
    const pills = document.querySelectorAll(".pill[data-tab]");
    const tabs = document.querySelectorAll(".tab");

    pills.forEach(p => p.addEventListener("click", () => {
      // Remove active state from all pills
      pills.forEach(pp => pp.classList.remove("active"));
      p.classList.add("active"); // Set clicked pill as active
      
      const id = p.getAttribute("data-tab");
      
      // Hide all tab sections
      tabs.forEach(t => t.classList.add("hidden"));
      // Show selected tab section
      document.getElementById(id)?.classList.remove("hidden");
      
      // Scroll to top of page for better UX
      window.scrollTo({ top: 0, behavior: "smooth" });
    }));

    /* ===========================
       USER NAME DISPLAY
       Loads and displays current user's name from localStorage
       =========================== */
    
    (function(){
      const n = localStorage.getItem("currentUserName") || "Student";
      const el = document.getElementById("lName");
      if (el) el.textContent = n;
    })();

    /* ===========================
       SUMMARY LOADING FUNCTION
       Fetches and displays chapter summaries from backend
       =========================== */
    
    async function loadSummaries() {
      const grid = document.querySelector("#summary .grid");
      if (!grid) return;
      
      grid.innerHTML = '<div class="loading-text">Loading summaries...</div>';

      // Get selected chapter ID from localStorage
      const chapterId = Number(localStorage.getItem("selectedChapterId"));
      if (!chapterId) {
        grid.innerHTML = '<div class="error-message">No chapter selected. Go to Dashboard and pick a chapter.</div>';
        return;
      }

      try {
        // Fetch all summaries from backend API
        const res = await fetch("http://127.0.0.1:8000/summaries");
        const summaries = await res.json();
        // Filter summaries for the selected chapter
        const filtered = summaries.filter((s) => s.chapter_id === chapterId);

        if (filtered.length > 0) {
          grid.innerHTML = "";
          filtered.forEach((summary) => {
            let text = summary.summary_data;
            
            // Parse summary text and add heading styling to section markers
            const lines = text.split('\n');
            
            for (let i = 0; i < lines.length; i++) {
              const line = lines[i].trim();
              
              // Identify section headings by various patterns
              if (line.startsWith('Section:') || line.startsWith('Section ')) {
                lines[i] = '<span class="heading">' + lines[i] + '</span>';
              }
              // Numbered sections like "1.1 Introduction"
              else if (/^\d+\.\d+\s/.test(line)) {
                lines[i] = '<span class="heading">' + lines[i] + '</span>';
              }
              // Standard section titles
              else if (line === 'Key Terms' || line === 'Chapter Summary' || line === 'High-Yield Exam Facts') {
                lines[i] = '<span class="heading">' + lines[i] + '</span>';
              }
            }
            
            // Reconstruct text with heading markup
            text = lines.join('\n');
            grid.innerHTML += `<div class="summary-text">${text}</div>`;
          });
        } else {
          grid.innerHTML = '<div class="error-message">No summaries found for this chapter.</div>';
        }
      } catch (e) {
        grid.innerHTML = `<div class="error-message">Error loading summaries: ${e.message}</div>`;
      }
    }

    /* ===========================
       FLASHCARDS LOADING FUNCTION
       Creates interactive flashcard carousel with navigation
       =========================== */
    
    async function loadFlashcards() {
      const grid = document.querySelector("#flashcards .grid");
      if (!grid) return;
      
      grid.innerHTML = '<div class="loading-text">Loading flashcards...</div>';

      // Get selected chapter ID from localStorage
      const chapterId = Number(localStorage.getItem("selectedChapterId"));
      if (!chapterId) {
        grid.innerHTML = '<div class="error-message">No chapter selected. Go to Dashboard and pick a chapter.</div>';
        return;
      }

      try {
        // Fetch all flashcards from backend API
        const res = await fetch("http://127.0.0.1:8000/flashcards");
        const flashcards = await res.json();
        // Filter flashcards for the selected chapter
        const filtered = flashcards.filter((f) => f.chapter_id === chapterId);

        if (filtered.length > 0) {
          // Build carousel HTML structure with navigation controls
          grid.innerHTML = `
            <div class="nav-arrow left" id="prev-card">←</div>
            <div class="flashcard-container" id="card-container"></div>
            <div class="nav-arrow right" id="next-card">→</div>
            <div class="flashcard-scrollbar-wrapper">
              <div class="flashcard-scrollbar" id="flashcard-scrollbar">
                <div class="flashcard-scrollbar-thumb" id="flashcard-scrollbar-thumb"></div>
              </div>
            </div>
          `;
          
          // Get references to navigation elements
          const container = document.getElementById('card-container');
          const prevBtn = document.getElementById('prev-card');
          const nextBtn = document.getElementById('next-card');
          const scrollbar = document.getElementById('flashcard-scrollbar');
          const scrollbarThumb = document.getElementById('flashcard-scrollbar-thumb');
          
          let currentCardIndex = 0; // Track which card is currently displayed
          let isFlipped = false; // Track if current card is showing answer
          
          // Parse flashcard data into topic and keypoint pairs
          const allCards = filtered.map((flashcard, idx) => {
            const raw = (flashcard.flashcard_data || '').replace(/\r/g, '');
            let topic = '', keypoint = '';
            
            // Parse flashcard format: "Topic | Key Point: explanation"
            if (/Key Point:/i.test(raw)) {
              const parts = raw.split(/Key Point:/i);
              topic = parts[0].trim();
              keypoint = parts.slice(1).join('Key Point:').trim();
            } 
            // Alternative format with pipe delimiter
            else if (raw.includes('|')) {
              const parts = raw.split('|');
              topic = parts[0].trim().replace(/\|+$/, "");
              keypoint = parts.slice(1).join(' ').trim();
            } 
            // Fallback: first line is topic, rest is keypoint
            else {
              const lines = raw.split('\n').map(s=>s.trim()).filter(Boolean);
              topic = lines.shift() || '';
              keypoint = lines.join(' ') || '';
            }

            // Clean up formatting artifacts
            topic = topic.replace(/\|/g, '').replace(/\[\d+\]/g, '').trim();
            keypoint = keypoint.replace(/\|/g, '').replace(/\[\d+\]/g, '').trim();
            
            return { topic, keypoint };
          });
          
          /**
           * Creates a flashcard DOM element
           * @param {number} index - Position in card array
           * @param {object} cardData - Object with topic and keypoint
           * @returns {HTMLElement} - Flashcard element
           */
          function createCard(index, cardData) {
            const cardEl = document.createElement('div');
            cardEl.className = 'card-item card-front';
            cardEl.dataset.index = index;
            cardEl.innerHTML = `<div class="flashcard-prompt">Tap to reveal (${index + 1}/${allCards.length})</div>`;
            
            // Click handler to flip card between question and answer
            cardEl.addEventListener('click', function() {
              // Only allow flipping the current card
              if (parseInt(cardEl.dataset.index) !== currentCardIndex) return;
              
              if (!isFlipped) {
                // Show answer side
                cardEl.classList.remove('card-front');
                cardEl.classList.add('card-back');
                cardEl.innerHTML = `
                  <div class="flashcard-title">${cardData.topic}</div>
                  <div class="flashcard-content">${cardData.keypoint}</div>
                `;
                isFlipped = true;
              } else {
                // Show question side
                cardEl.classList.remove('card-back');
                cardEl.classList.add('card-front');
                cardEl.innerHTML = `<div class="flashcard-prompt">Tap to reveal (${index + 1}/${allCards.length})</div>`;
                isFlipped = false;
              }
            });
            
            return cardEl;
          }
          
          /**
           * Updates scrollbar thumb position and width based on current card
           */
          function updateScrollbar() {
            const thumbWidth = (1 / allCards.length) * 100;
            const thumbPosition = (currentCardIndex / allCards.length) * 100;
            scrollbarThumb.style.width = thumbWidth + '%';
            scrollbarThumb.style.left = thumbPosition + '%';
          }
          
          /**
           * Updates CSS classes for all cards based on their position relative to current card
           * Creates stacking effect for visited/unvisited cards
           */
          function updateCardPositions() {
            const cards = Array.from(container.children);
            
            cards.forEach((card, idx) => {
              card.classList.remove('visited', 'current', 'unvisited');
              
              if (idx < currentCardIndex) {
                card.classList.add('visited'); // Cards before current
              } else if (idx === currentCardIndex) {
                card.classList.add('current'); // Current card
              } else {
                card.classList.add('unvisited'); // Cards after current
              }
            });
            
            // Update navigation button states
            prevBtn.classList.toggle('disabled', currentCardIndex === 0);
            nextBtn.classList.toggle('disabled', currentCardIndex === allCards.length - 1);
            updateScrollbar();
          }
          
          /**
           * Navigate to next card (decreases index as we're moving through stack)
           */
          function goToNext() {
            if (currentCardIndex > 0) {
              currentCardIndex--;
              isFlipped = false; // Reset flip state
              updateCardPositions();
            }
          }
          
          /**
           * Navigate to previous card (increases index)
           */
          function goToPrev() {
            if (currentCardIndex < allCards.length - 1) {
              currentCardIndex++;
              isFlipped = false; // Reset flip state
              updateCardPositions();
            }
          }
          
          // Bind navigation buttons
          prevBtn.addEventListener('click', goToPrev);
          nextBtn.addEventListener('click', goToPrev);
          
          /**
           * Handle clicks on scrollbar track to jump to specific card
           */
          scrollbar.addEventListener('click', function(e) {
            if (e.target === scrollbarThumb) return; // Ignore clicks on thumb itself
            const rect = scrollbar.getBoundingClientRect();
            const clickPosition = (e.clientX - rect.left) / rect.width;
            currentCardIndex = Math.round(clickPosition * (allCards.length - 1));
            isFlipped = false;
            updateCardPositions();
          });
          
          // Scrollbar thumb dragging functionality
          let isDragging = false;
          let startX = 0;
          let startIndex = 0;
          
          /**
           * Initialize drag operation on thumb
           */
          scrollbarThumb.addEventListener('mousedown', function(e) {
            isDragging = true;
            startX = e.clientX;
            startIndex = currentCardIndex;
            e.preventDefault();
          });
          
          /**
           * Update card position during drag
           */
          document.addEventListener('mousemove', function(e) {
            if (!isDragging) return;
            const rect = scrollbar.getBoundingClientRect();
            const deltaX = e.clientX - startX;
            const deltaIndex = Math.round((deltaX / rect.width) * allCards.length);
            const newIndex = Math.max(0, Math.min(allCards.length - 1, startIndex + deltaIndex));
            if (newIndex !== currentCardIndex) {
              currentCardIndex = newIndex;
              isFlipped = false;
              updateCardPositions();
            }
          });
          
          /**
           * End drag operation
           */
          document.addEventListener('mouseup', function() {
            isDragging = false;
          });
          
          // Create and add all flashcard elements to container
          allCards.forEach((cardData, idx) => {
            const card = createCard(idx, cardData);
            container.appendChild(card);
          });
          
          updateCardPositions(); // Initialize card positions
          
          /**
           * Handle mouse wheel scrolling for card navigation
           * Supports both horizontal and vertical scroll gestures
           */
          container.addEventListener('wheel', function(e) {
            const threshold = 30; // Minimum scroll distance to trigger navigation
            
            // Check if scroll is primarily horizontal
            if (Math.abs(e.deltaX) > Math.abs(e.deltaY)) {
              if (Math.abs(e.deltaX) > threshold) {
                if (e.deltaX > 0 && currentCardIndex < allCards.length - 1) {
                  currentCardIndex++;
                  isFlipped = false;
                  updateCardPositions();
                  e.preventDefault();
                } else if (e.deltaX < 0 && currentCardIndex > 0) {
                  currentCardIndex--;
                  isFlipped = false;
                  updateCardPositions();
                  e.preventDefault();
                }
              }
            } 
            // Handle vertical scroll
            else if (Math.abs(e.deltaY) > threshold) {
              if (e.deltaY > 0 && currentCardIndex < allCards.length - 1) {
                currentCardIndex++;
                isFlipped = false;
                updateCardPositions();
                e.preventDefault();
              } else if (e.deltaY < 0 && currentCardIndex > 0) {
                currentCardIndex--;
                isFlipped = false;
                updateCardPositions();
                e.preventDefault();
              }
            }
          }, { passive: false }); // Allow preventDefault
        } else {
          grid.innerHTML = '<div class="error-message">No flashcards found for this chapter.</div>';
        }
      } catch (e) {
        grid.innerHTML = `<div class="error-message">Error loading flashcards: ${e.message}</div>`;
      }
    }

    /* ===========================
       RAG DOUBT ANSWERING INTEGRATION
       AI-powered Q&A using Flowise API with chapter-specific context
       =========================== */
    
    const ragApiUrl = "https://cloud.flowiseai.com/api/v1/prediction/95ac6cf3-9302-44b5-b406-28fb18d3dd31";
    const ragChatForm = document.getElementById('rag-chat-form');
    const ragChatInput = document.getElementById('rag-chat-input');
    const ragChatHistory = document.getElementById('rag-chat-history');

    if (ragChatForm && ragChatInput && ragChatHistory) {
      ragChatForm.addEventListener('submit', async function(e) {
        e.preventDefault();
        const question = ragChatInput.value.trim();
        if (!question) return; // Ignore empty questions
        
        // Retrieve selected chapter to verify content availability
        const selectedChapterId = Number(localStorage.getItem("selectedChapterId"));
        
        // Display user's question in chat history
        ragChatHistory.innerHTML += `<div style="text-align:left;"><span style="font-weight:700;color:#233876;">You:</span> <span style="color:#fff;">${question}</span></div>`;
        ragChatInput.value = '';
        ragChatInput.disabled = true; // Prevent multiple submissions
        
        // Show loading indicator while waiting for AI response
        ragChatHistory.innerHTML += `<div id="rag-loading" style="color:#aaa;text-align:left;">AI is thinking...</div>`;
        ragChatHistory.scrollTop = ragChatHistory.scrollHeight;
        
        // Validate chapter selection
        if (!selectedChapterId) {
          document.getElementById('rag-loading').remove();
          ragChatHistory.innerHTML += `<div style="text-align:left;"><span style="font-weight:700;color:#ffe066;">AI:</span> <span style="color:var(--muted);">Please select a chapter from the Dashboard first.</span></div>`;
          ragChatHistory.scrollTop = ragChatHistory.scrollHeight;
          ragChatInput.disabled = false;
          ragChatInput.focus();
          return;
        }
        
        // Check if selected chapter has available content (only Chapter 1 currently)
        if (selectedChapterId !== 1) {
          document.getElementById('rag-loading').remove();
          ragChatHistory.innerHTML += `<div style="text-align:left;"><span style="font-weight:700;color:#ffe066;">AI:</span> <span style="color:var(--muted);">This chapter is not ready yet. Currently, only Chapter 1 content is available. Please select Chapter 1 from the Dashboard to ask questions.</span></div>`;
          ragChatHistory.scrollTop = ragChatHistory.scrollHeight;
          ragChatInput.disabled = false;
          ragChatInput.focus();
          return;
        }
        
        try {
          // Send question to Flowise RAG API
          const res = await fetch(ragApiUrl, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ question })
          });
          const data = await res.json();
          document.getElementById('rag-loading').remove();
          
          // Display AI's answer in chat history
          ragChatHistory.innerHTML += `<div style="text-align:left;"><span style="font-weight:700;color:#ffe066;">AI:</span> <span style="color:var(--muted);">${data.text || "No answer."}</span></div>`;
          ragChatHistory.scrollTop = ragChatHistory.scrollHeight;
        } catch (err) {
          // Handle API errors
          document.getElementById('rag-loading').remove();
          ragChatHistory.innerHTML += `<div style="color:#f55;text-align:left;">Error: Could not get answer.</div>`;
        }
        
        // Re-enable input for next question
        ragChatInput.disabled = false;
        ragChatInput.focus();
      });
    }

    /* ===========================
       INITIAL PAGE LOAD
       Load content for active tabs when page first opens
       =========================== */
    
    loadSummaries();
    loadFlashcards();
  </script>
</body>
</html>